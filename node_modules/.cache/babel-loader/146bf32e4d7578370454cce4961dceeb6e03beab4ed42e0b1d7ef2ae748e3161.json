{"ast":null,"code":"function render(timestamp, frame) {\n  if (frame) {\n    const referenceSpace = renderer.xr.getReferenceSpace();\n    const session = renderer.xr.getSession();\n    if (hitTestSourceRequested === false) {\n      session.requestReferenceSpace(\"viewer\").then(function (referenceSpace) {\n        session.requestHitTestSource({\n          space: referenceSpace\n        }).then(function (source) {\n          hitTestSource = source;\n        });\n      });\n      session.addEventListener(\"end\", function () {\n        hitTestSourceRequested = false;\n        hitTestSource = null;\n      });\n      hitTestSourceRequested = true;\n    }\n    if (hitTestSource) {\n      const hitTestResults = frame.getHitTestResults(hitTestSource);\n\n      // Initialize hitTestResult to null\n      let hitTestResult = null;\n\n      // Iterate over hitTestResults and filter for horizontal surfaces\n      for (const hit of hitTestResults) {\n        const pose = hit.getPose(referenceSpace);\n        const normal = pose.transform.orientation;\n\n        // Check if the normal is approximately aligned with the Y-axis\n        if (Math.abs(normal[0]) < 0.1 && Math.abs(normal[1] - 1) < 0.1 && Math.abs(normal[2]) < 0.1) {\n          hitTestResult = hit;\n          break;\n        }\n      }\n      if (hitTestResult) {\n        const pose = hitTestResult.getPose(referenceSpace);\n        reticle.visible = true;\n        reticle.matrix.fromArray(pose.transform.matrix);\n\n        // Hide the \"scanning\" message when hit test results are available\n        setHitTestVisible(false);\n      } else {\n        reticle.visible = false;\n      }\n    }\n  }\n  renderer.render(scene, camera);\n}","map":{"version":3,"names":["render","timestamp","frame","referenceSpace","renderer","xr","getReferenceSpace","session","getSession","hitTestSourceRequested","requestReferenceSpace","then","requestHitTestSource","space","source","hitTestSource","addEventListener","hitTestResults","getHitTestResults","hitTestResult","hit","pose","getPose","normal","transform","orientation","Math","abs","reticle","visible","matrix","fromArray","setHitTestVisible","scene","camera"],"sources":["D:/3D-WebXR-Furniture/src/App.js"],"sourcesContent":["function render(timestamp, frame) {\r\n  if (frame) {\r\n    const referenceSpace = renderer.xr.getReferenceSpace();\r\n    const session = renderer.xr.getSession();\r\n\r\n    if (hitTestSourceRequested === false) {\r\n      session.requestReferenceSpace(\"viewer\").then(function (referenceSpace) {\r\n        session.requestHitTestSource({ space: referenceSpace }).then(function (source) {\r\n          hitTestSource = source;\r\n        });\r\n      });\r\n\r\n      session.addEventListener(\"end\", function () {\r\n        hitTestSourceRequested = false;\r\n        hitTestSource = null;\r\n      });\r\n\r\n      hitTestSourceRequested = true;\r\n    }\r\n\r\n    if (hitTestSource) {\r\n      const hitTestResults = frame.getHitTestResults(hitTestSource);\r\n\r\n      // Initialize hitTestResult to null\r\n      let hitTestResult = null;\r\n\r\n      // Iterate over hitTestResults and filter for horizontal surfaces\r\n      for (const hit of hitTestResults) {\r\n        const pose = hit.getPose(referenceSpace);\r\n        const normal = pose.transform.orientation;\r\n\r\n        // Check if the normal is approximately aligned with the Y-axis\r\n        if (Math.abs(normal[0]) < 0.1 && Math.abs(normal[1] - 1) < 0.1 && Math.abs(normal[2]) < 0.1) {\r\n          hitTestResult = hit;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (hitTestResult) {\r\n        const pose = hitTestResult.getPose(referenceSpace);\r\n        reticle.visible = true;\r\n        reticle.matrix.fromArray(pose.transform.matrix);\r\n\r\n        // Hide the \"scanning\" message when hit test results are available\r\n        setHitTestVisible(false);\r\n      } else {\r\n        reticle.visible = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  renderer.render(scene, camera);\r\n}\r\n"],"mappings":"AAAA,SAASA,MAAMA,CAACC,SAAS,EAAEC,KAAK,EAAE;EAChC,IAAIA,KAAK,EAAE;IACT,MAAMC,cAAc,GAAGC,QAAQ,CAACC,EAAE,CAACC,iBAAiB,CAAC,CAAC;IACtD,MAAMC,OAAO,GAAGH,QAAQ,CAACC,EAAE,CAACG,UAAU,CAAC,CAAC;IAExC,IAAIC,sBAAsB,KAAK,KAAK,EAAE;MACpCF,OAAO,CAACG,qBAAqB,CAAC,QAAQ,CAAC,CAACC,IAAI,CAAC,UAAUR,cAAc,EAAE;QACrEI,OAAO,CAACK,oBAAoB,CAAC;UAAEC,KAAK,EAAEV;QAAe,CAAC,CAAC,CAACQ,IAAI,CAAC,UAAUG,MAAM,EAAE;UAC7EC,aAAa,GAAGD,MAAM;QACxB,CAAC,CAAC;MACJ,CAAC,CAAC;MAEFP,OAAO,CAACS,gBAAgB,CAAC,KAAK,EAAE,YAAY;QAC1CP,sBAAsB,GAAG,KAAK;QAC9BM,aAAa,GAAG,IAAI;MACtB,CAAC,CAAC;MAEFN,sBAAsB,GAAG,IAAI;IAC/B;IAEA,IAAIM,aAAa,EAAE;MACjB,MAAME,cAAc,GAAGf,KAAK,CAACgB,iBAAiB,CAACH,aAAa,CAAC;;MAE7D;MACA,IAAII,aAAa,GAAG,IAAI;;MAExB;MACA,KAAK,MAAMC,GAAG,IAAIH,cAAc,EAAE;QAChC,MAAMI,IAAI,GAAGD,GAAG,CAACE,OAAO,CAACnB,cAAc,CAAC;QACxC,MAAMoB,MAAM,GAAGF,IAAI,CAACG,SAAS,CAACC,WAAW;;QAEzC;QACA,IAAIC,IAAI,CAACC,GAAG,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,IAAIG,IAAI,CAACC,GAAG,CAACJ,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,GAAG,IAAIG,IAAI,CAACC,GAAG,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,EAAE;UAC3FJ,aAAa,GAAGC,GAAG;UACnB;QACF;MACF;MAEA,IAAID,aAAa,EAAE;QACjB,MAAME,IAAI,GAAGF,aAAa,CAACG,OAAO,CAACnB,cAAc,CAAC;QAClDyB,OAAO,CAACC,OAAO,GAAG,IAAI;QACtBD,OAAO,CAACE,MAAM,CAACC,SAAS,CAACV,IAAI,CAACG,SAAS,CAACM,MAAM,CAAC;;QAE/C;QACAE,iBAAiB,CAAC,KAAK,CAAC;MAC1B,CAAC,MAAM;QACLJ,OAAO,CAACC,OAAO,GAAG,KAAK;MACzB;IACF;EACF;EAEAzB,QAAQ,CAACJ,MAAM,CAACiC,KAAK,EAAEC,MAAM,CAAC;AAChC"},"metadata":{},"sourceType":"module","externalDependencies":[]}